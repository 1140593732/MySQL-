# 1.	子查询的介绍

### 1.1	子查询的基本使用

​	**•**	子查询的基本语法结构：

```sql
SELECT		...,...
FROM		table
WHERE		column operator (
							SELECT	...,...
							FROM	table);
```

### 1.2子查询的分类

​	**•**	**分类1**：我们按子（内）查询的结果返回一条还是多条记录，将子查询分为 **单行子查询** 、 **多行子查询** 。

​	**•**	**分类2**：我们按（子）查询中查询条件是否依赖于外层查询中的某个值（或者是否被执行多次，因为子查询条件依赖于外层查询的某个值，所以子查询的处理		不只一次，要反复求值，以供外层查询使用），将子查询划分为**相关（或关联）子查询**和**不相关（或非关联）子查询**。

​			৹	子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条 件进行执行，那么这样的子查询叫做不相关子查				  询。

​			৹	 同样，如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查 询，然后再将结果反馈给外部，这种嵌套的执行方				  式就称为相关子查询。



# 2.	单行子查询

### 2.1	单行比较操作符

| 操作符 |   含义   |
| :----: | :------: |
|   =    |   等于   |
|   >    |   大于   |
|   >=   | 大于等于 |
|   <    |   小于   |
|   <=   | 小于等于 |
|   <>   |  不等于  |

### 2.2	代码示例

```sql
#查询工资大于149号员工工资的员工信息

SELECT last_name
FROM   employees
WHERE  salary > 
				(SELECT salary
                FROM	employees
                WHERE	employee_id = 149);
```

```sql
#查询与141号或174号员工的manager_id和department_id相同的其他员工的employee_id，manager_id，department_id

#方式一：不成对比较
SELECT employee_id, manager_id, department_id
FROM employees
WHERE manager_id IN
					(SELECT manager_id
					 FROM employees
					 WHERE employee_id IN (174,141))
AND department_id IN
					(SELECT department_id
					 FROM employees
					 WHERE employee_id IN (174,141))
AND employee_id NOT IN(174,141);

#方式二：成对比较
SELECT employee_id, manager_id, department_id
FROM employees
WHERE (manager_id, department_id) IN
									(SELECT manager_id, department_id
								 	 FROM employees
								 	 WHERE employee_id IN (141,174))
AND employee_id NOT IN (141,174);
```

```sql
#查询最低工资大于50号部门最低工资的部门id和其最低工资

SELECT department_id, MIN(salary) min_sal
FROM employees
GROUP BY department_id
HAVING min_sal >
				(SELECT MIN(salary)
				 FROM employees
				 WHERE department_id = 50);
```

### 2.3	CASE中的子查询

​	**•**	CASE语法

```SQL
CASE SEX WHEN '1' THEN '男'
		 WHEN '0' THEN '女'
		 ELSE '其他' END;
		 
CASE WHEN sex = '1' THEN '男'
	 WHEN sex = '0' THEN '女'
	 ELSE '其他' END;
```

```sql
#：显式员工的employee_id,last_name和location。其中，若员工department_id与location_id为1800的department_id相同，则location为’Canada’，其余则为’USA’。
SELECT employee_id, last_name,
	   (CASE department_id
		WHEN
			(SELECT department_id FROM departments
			 WHERE location_id = 1800)
		THEN 'Canada' ELSE 'USA' END) location
FROM employees;
```



# 3.	多行子查询

| 操作符 |                           含义                           |
| :----: | :------------------------------------------------------: |
|   IN   |                   等于列表中的任意一个                   |
|  ANY   | 需要和单行比较操作符一起使用，和子查询返回的某一个值比较 |
|  ALL   |  需要和单行比较操作符一起使用，和子查询返回的所有值比较  |
|  SOME  |        实际上是ANY的别名，作用相同，一般常使用ANY        |

```sql
#返回其他job_id中比job_id为‘IT_PROG’部门任一工资低的员工的员工号、姓名、job_id 以及salary

SELECT  employee_id, last_name, job_id, salary
FROM	employees
WHERE 	salary < ANY
					(SELECT salary
					 FROM   employees  
            		 WHERE 	JOB_ID = 'IT_PROG');
AND		job_id <> 'IT_PROG';
```

```sql
#查询平均工资最低的部门id

SELECT department_id
FROM employees
GROUP BY department_id
HAVING AVG(salary) <= ALL (SELECT AVG(salary) 
						   FROM employees
						   GROUP BY department_id);
```



# 4.	相关子查询

如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件 关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为 `关联子查询 `。

相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询。

<img src="https://cdn.jsdelivr.net/gh/1140593732/MyImg/img/20220803214551.png" style="zoom:50%;" />

```sql
#查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_id

#方式一：相关子查询
SELECT last_name, salary, department_id
FROM   employees outer
WHERE  salary > 
				(SELECT AVG(salary)
                 FROM 	employees
                 WHERE	department_id = outer.department_id);

#方式二：在FROM中使用子查询，作为一个表
SELECT last_name, salary, e1.department_id
FROM employees e1, (SELECT department_id, AVG(salary) dept_avg_sal 
                    FROM employees 
                    GROUP BY department_id) e2
WHERE e1.`department_id` = e2.department_id
AND e2.dept_avg_sal < e1.`salary`;
```

```SQL
#若employees表中employee_id与job_history表中employee_id相同的数目不小于2，输出这些相同id的员工的employee_id,last_name和其job_id

SELECT e.employee_id, last_name,e.job_id
FROM employees e
WHERE 2 <= (SELECT COUNT(*)
			FROM job_history
			WHERE employee_id = e.employee_id);
```

在ORDER BY中使用子查询:

```sql
#查询员工的id，salary，按照departmen_name排序

SELECT employee_id,salary
FROM employees e
ORDER BY (SELECT department_name
		 FROM departments d
		 WHERE e.`department_id` = d.`department_id`);
```

### 4.3	EXISTS与NOT EXISTS关键字

