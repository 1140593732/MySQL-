# 1.	聚合函数介绍

​	**•**	聚合函数类型

​		৹	**AVG（）**

​		৹	**SUM（）**

​		৹	**MAX（）**

​		৹	**MIN（）**

​		৹	**COUNT（）**

**•**	聚合函数语法

```sql
SELECT			[column,] group function(column),...
FROM			table
[WHERE			condition]
[GROUP BY		column]
[ORDER BY		column];
```

### 1.1	AVG和SUM函数

可以对**数值型数据**使用`AVG`和`SUM`函数

```sql
SELECT AVG(salary), MAX(salary),MIN(salary), SUM(salary)
FROM employees
WHERE job_id LIKE '%REP%';
```

<img src="https://cdn.jsdelivr.net/gh/1140593732/MyImg/img/20220803191833.png" style="zoom: 80%;" />

### 1.2	MIN和MAX函数

可以对**任意数据类型**的数据使用` MIN `和` MAX` 函数。

```sql
SELECT MIN(hire_date), MAX(hire_date)
FROM employees;
```

<img src="https://cdn.jsdelivr.net/gh/1140593732/MyImg/img/20220803192032.png" style="zoom:80%;" />

### 1.3	COUNT函数

​	**•**	`COUNT(*)`返回表中记录总数，适用于任意数据类型。

```sql
SELECT COUNT(*)
FROM employees
WHERE department_id = 50;
```

<img src="https://cdn.jsdelivr.net/gh/1140593732/MyImg/img/20220803192312.png" style="zoom:80%;" />

​	**•**	`COUNT(列名)` 返回**此列不为空**的记录总数。

```sql
SELECT COUNT(commission_pct)
FROM employees
WHERE department_id = 50;
```

<img src="https://cdn.jsdelivr.net/gh/1140593732/MyImg/img/20220803192600.png" style="zoom:80%;" />



# 2.	聚合函数用法

### 2.1	基本用法

![](https://cdn.jsdelivr.net/gh/1140593732/MyImg/img/20220803193731.png)

可以使用`GROUP BY`子句将表中的数据分成若干组

```sql
SELECT column, group_function(column)
FROM table
[WHERE condition]
[GROUP BY group_by_expression]
[ORDER BY column];
```

​		৹	**WHERE一定放在FROM后**

​		৹	在SELECT列表中所有未包含在组函数中的列都应该包含在 GROUP BY子句中，而包含在 GROUP BY 子句中的列不必包含在SELECT 列表中。

```sql
SELECT department_id, AVG(salary)
FROM employees
GROUP BY department_id ;
```

<img src="https://cdn.jsdelivr.net/gh/1140593732/MyImg/img/20220803194135.png" style="zoom:67%;" />

### 2.2	使用多个列分组

<img src="https://cdn.jsdelivr.net/gh/1140593732/MyImg/img/20220803194304.png" style="zoom:67%;" />

```sql
SELECT department_id dept_id, job_id, SUM(salary)
FROM employees
GROUP BY department_id, job_id ;
```

<img src="https://cdn.jsdelivr.net/gh/1140593732/MyImg/img/20220803194439.png" style="zoom:50%;" />

​	**•**	可以在GROUP BY之后使用`WITH ROLLUP`关键字，若如此做，将会在查询出的记录当中增加一条记录，该记录为查询出的记录总数。

```sql
SELECT department_id,AVG(salary)
FROM employees
WHERE department_id > 80
GROUP BY department_id WITH ROLLUP;
```



# 3.	HAVING

### 3.1	基本使用

<img src="https://cdn.jsdelivr.net/gh/1140593732/MyImg/img/20220803194843.png" style="zoom:50%;" />

​	**•**	**过滤分组：HAVING子句**

​		৹	行已经被分组。

​		৹	使用了聚合函数。

​		৹	满足HAVING 子句中条件的分组将被显示。

​		৹	HAVING 不能单独使用，必须要跟 GROUP BY 一起使用。

```sql
SELECT department_id, MAX(salary)
FROM employees
GROUP BY department_id
HAVING MAX(salary)>10000 ;
```

![](https://cdn.jsdelivr.net/gh/1140593732/MyImg/img/20220803195330.png)

​	**•**	**不能在WHERE子句中使用聚合函数**

### 3.2	WHERE和HAVING的比较

|            |             执行顺序和效率             | 能否使用分组中的计算函数 |
| :--------: | :------------------------------------: | :----------------------: |
| **WHERE**  |      先筛选数据再关联，执行效率高      |           不能           |
| **HAVING** | 在最后的结果集中进行筛选，执行效率较低 |            能            |



# 4.	SELECT的执行顺序

### 4.1	查询的结构

```sql
#方式1：
SELECT ...,....,...
FROM ...,...,....
WHERE 多表的连接条件
AND 不包含组函数的过滤条件
GROUP BY ...,...
HAVING 包含组函数的过滤条件
ORDER BY ... ASC/DESC
LIMIT ...,...


#方式2：
SELECT ...,....,...
FROM ... JOIN ...
ON 多表的连接条件
JOIN ...
ON ...
WHERE 不包含组函数的过滤条件
AND/OR 不包含组函数的过滤条件
GROUP BY ...,...
HAVING 包含组函数的过滤条件
ORDER BY ... ASC/DESC
LIMIT ...,...


#其中：
#（1）from：从哪些表中筛选
#（2）on：关联多表查询时，去除笛卡尔积
#（3）where：从表中筛选的条件
#（4）group by：分组依据
#（5）having：在统计结果中再次筛选
#（6）order by：排序
#（7）limit：分页
```

### 4.2	查询的顺序

SELECT查询的两个顺序：

**1.关键字的顺序：**

```sql
SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT...
```

**2.SELECT 语句的执行顺序（在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）：**

```sql
FROM -> WHERE -> GROUP BY -> HAVING -> SELECT 的字段 -> DISTINCT -> ORDER BY -> LIMIT
```

### 4.3	SQL的执行原理

​	**•**	SELECT 是先执行 `FROM `这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：

​		1.	首先先通过` CROSS JOIN `求笛卡尔积，相当于得到虚拟表 `vt（virtual table）1-1`；

​		2.	通过 `ON` 进行筛选，在虚拟表 `vt1-1` 的基础上进行筛选，得到虚拟表`vt1-2`；

​		3.	添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟 表 `vt1-2` 的基础上增加外部行，得到虚拟表` vt1-3`。

​		如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得 到是我们的原始数据。

​	**•**	接着就是`WHERE`，通过过滤条件对查询进行过滤。

​	**•**	然后进入第三步和第四步，也就是 `GROUP`和 `HAVING `阶段 。在这个阶段中，实际上是在虚拟表 `vt2 `的 基础上进行分组和分组过滤，得到中间的虚拟表 `vt3 `		  和`vt4` 。

​	**•**	当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到 SELECT 和 DISTINCT 阶段 。

​	**•**	首先在 `SELECT `阶段会提取想要的字段，然后在 `DISTINCT `阶段过滤掉重复的行，分别得到中间的虚拟表 `vt5-1 `和 `vt5-2` 。

​	**•**	当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是 `ORDER BY` 阶段 ，得到 虚拟表` vt6` 。

​	**•**	最后在 `vt6` 的基础上，取出指定行的记录，也就是 LIMIT 阶段 ，得到最终的结果，对应的是虚拟表` vt7 `。