# 1.	多表查询分类

## 分类1：等值连接与非等值连接

### 等值连接

​	**•**	在连接条件中使用等于号(=)运算符比较被连接列的列值，其查询结果中列出被连接表中的所有列，包括其中的重复属性。 （区别于自然连接）

```sql
SELECT employees.employee_id, employees.last_name, employees.department_id, departments.department_id, departments.location_id
FROM employees, departments
WHERE employees.department_id = departments.department_id;
```

#### 拓展1：多个连接条件使用AND操作符

```SQL
SELECT * 
FROM employees
WHERE employees.department_id = 50 AND employees.salary > 3000
```

#### 拓展2：区分重复列名

​	**•**	**多个表中有相同列时，必须在列名之前加上表名前缀。**

​	**•**	在不同表中具有相同列名的列可以用 表名 加以区分。

```sql
SELECT employees.last_name, departments.department_name,employees.department_id
FROM employees, departments
WHERE employees.department_id = departments.department_id;
```

#### 拓展3：表的别名

​	**•**	使用别名可以简化查询。

​	**•**	列名前使用表名前缀可以提高查询效率。

```sql
SELECT e.employee_id, e.last_name, e.department_id,
d.department_id, d.location_id
FROM employees e , departments d
WHERE e.department_id = d.department_id;

-- 一旦使用表的别名，在查询字段，过滤条件当中就只能使用别名进行替代！
```

### 非等值连接

​	**•**	在连接条件使用除等于运算符以外的其它比较运算符比较被连接的 列的列值。这些运算符包括>、>=、<=、<、!>、!<和<>。

```sql
SELECT e.last_name, e.salary, j.gra
FROM   employees e, job_grade j
WHERE   e.salary BETWEEN j.lowest_sal AND j.highest_sal;
```

![](https://cdn.jsdelivr.net/gh/1140593732/MyImg/img/20220803105405.png)

## 分类2：自连接与非自连接

<img src="https://cdn.jsdelivr.net/gh/1140593732/MyImg/img/20220803105705.png" style="zoom:50%;" />

​	**•**	当table1和table2本质上是同一张表，只是用取别名的方式虚拟成两张表以代表不同的意义。然后两个表再进行内连接，外连接等查询。

```sql
-- 查询employees表，返回“Xxx works for Xxx”

SELECT CONCAT(worker.last_name ,' works for '
, manager.last_name)
FROM employees worker, employees manager
WHERE worker.manager_id = manager.employee_id ;
```

## 分类3：内连接与外连接

除了查询满足条件的记录以外，外连接还可以查询某一方不满足条件的记录。

<img src="https://cdn.jsdelivr.net/gh/1140593732/MyImg/img/20220803110509.png" style="zoom:50%;" />

​	**•**	内连接: 合并具有同一列的两个以上的表的行, **结果集中不包含一个表与另一个表不匹配的行**

​	**•**	外连接: 两个表在连接过程中除了返回满足连接条件的行以外还**返回左（或右）表中不满足条件的行 ，这种连接称为左（或右）外连接。**没有匹配的行时, 			结果表中相应的列为空(NULL)。

​		৹	如果是左外连接，则连接条件中左边的表也称为`主表`，右边的表称为`从表` 。

​		 	 如果是右外连接，则连接条件中右边的表也称为`主表` ，左边的表称为`从表`。



# 2.	多表查询实现

### 2.1	内连接（INNER JOIN）的实现

​	**•**	语法：

```sql
SELECT 字段列表
FROM A表 INNER JOIN B表   -- INNER可省略
ON 关联条件
WHERE 等其他子句;
```

```SQL
SELECT	e.employee_id, l.city, d.department_name
FROM	employees e
JOIN	departments d
ON		d.department_id = e.department_id
JOIN	locations l
ON		d.location_id = l.location_id;
```

![](https://cdn.jsdelivr.net/gh/1140593732/MyImg/img/20220803112032.png)

### 2.2	外连接（OUTER JOIN）实现

#### 2.2.1	左外连接(LEFT OUTER JOIN)

​	**•**	语法：

```sql
#左边连接的表（A表）中不满足条件的行也会被查询出来

SELECT 字段列表
FROM A表 LEFT JOIN B表
ON 关联条件
WHERE 等其他子句;
```

```sql
#查找员工信息，包括姓名，所在部门的id以及名称（存在有员工没有分配部门）

SELECT e.last_name, e.department_id, d.department_name
FROM employees e
LEFT OUTER JOIN departments d
ON (e.department_id = d.department_id) ;
```

![](https://cdn.jsdelivr.net/gh/1140593732/MyImg/img/20220803112559.png)

#### 2.2.2	右外连接(RIGHT OUTER JOIN)

​	**•**	语法：

```sql
#右边连接的表（B表）中不满足条件的行也会被查询出来

SELECT 字段列表
FROM A表 RIGHT JOIN B表
ON 关联条件
WHERE 等其他子句;
```

#### 2.2.3	满外连接（FULL OUTER JOIN）

​	**•**	满外连接的结果 = 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。

​	**•**	SQL99是支持满外连接的。使用`FULL JOIN` 或 `FULL OUTER JOIN`来实现。

​	**•**	需要注意的是，MySQL不支持FULL JOIN，但是可以用 LEFT JOIN UNION RIGHT join代替。



# 3.	UNION的使用

​	**•**	合并查询结果 利用UNION关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并 时，两个表对应的列数和数据类型必须相同，并且		  相互对应。各个SELECT语句之间使用UNION或UNION ALL关键字分隔。

​	**•**	语法：

```sql
SELECT column,... FROM table1
UNION 	#或者UNION ALL
SELECT column,... FROM table2
```

**UNION操作符**：符返回两个查询的结果集的并集，去除重复记录。

<img src="https://cdn.jsdelivr.net/gh/1140593732/MyImg/img/20220803114509.png" style="zoom:50%;" />

**UNION ALL操作符**：返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重。

<img src="https://cdn.jsdelivr.net/gh/1140593732/MyImg/img/20220803114605.png" style="zoom:50%;" />

```sql
#查询部门编号>90或邮箱包含a的员工信息

#方式一
SELECT * FROM employees WHERE email LIKE '%a%' OR department_id>90;

#方式二
SELECT * FROM employees WHERE email LIKE '%a%'
UNION
SELECT * FROM employees WHERE department_id>90;
```

执行`UNION ALL`语句时所需要的资源比`UNION`语句少。如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用`UNION ALL`语句，以提高数据查询的效率



# 4.	七种SQL JOINS的实现

![](https://cdn.jsdelivr.net/gh/1140593732/MyImg/img/2022831658.png)



# 5.	SQL99语法新特性

### 5.1	自然连接

SQL99 在 SQL92 的基础上提供了一些特殊语法，比如 `NATURAL JOIN` 用来表示自然连接。我们可以把 自然连接理解为 SQL92 中的等值连接。它会帮你自动查询两张连接表中 所有相同的字段 ，然后进行 等值 连接 。

在SQL92标准中：

```sql
SELECT employee_id,last_name,department_name
FROM employees e JOIN departments d
ON e.`department_id` = d.`department_id`
AND e.`manager_id` = d.`manager_id`;
```

在 SQL99 中可以写成：

```sql
SELECT employee_id,last_name,department_name
FROM employees e NATURAL JOIN departments d;
```

### 5.2	USING连接

当进行连接的时候，SQL99还支持使用 `USING` 指定数据表里的 同名字段 进行等值连接。但是只能配合`JOIN`一起使用。比如：

```sql
SELECT employee_id,last_name,department_name
FROM employees e JOIN departments d
USING (department_id);
```

可以看出与自然连接 `NATURAL JOIN` 不同的是，`USING` 指定了具体的相同的字段名称，需要在 `USING` 的括号 () 中填入要指定的同名字段。同时使用 `JOIN...USING`可以简化` JOIN ON `的等值连接。它与下 面的 SQL 查询结果是相同的：

```sql
SELECT employee_id,last_name,department_name
FROM employees e ,departments d
WHERE e.department_id = d.department_id;
```

### 5.3	表的连接约束条件

表连接的约束条件可以有三种方式：`WHERE`, ` ON`,  `USING`

​	**•**	`WHERE`：适用于所有关联查询

​	**•**	`ON` ：只能和`JOIN`一起使用，只能写关联条件。虽然关联条件可以并到`WHERE`中和其他条件一起写，但分开写可读性更好。

​	**•**	`USING`：只能和`JOIN`一起使用，而且要求两个关联字段在关联表中名称一致，而且只能表示关联字段值相等

```sql
#关联条件
#把关联条件写在where后面
SELECT last_name,department_name
FROM employees,departments
WHERE employees.department_id = departments.department_id;


#把关联条件写在on后面，只能和JOIN一起使用
SELECT last_name,department_name
FROM employees INNER JOIN departments
ON employees.department_id = departments.department_id;

SELECT last_name,department_name
FROM employees CROSS JOIN departments
ON employees.department_id = departments.department_id;

SELECT last_name,department_name
FROM employees JOIN departments
ON employees.department_id = departments.department_id;


#把关联字段写在using()中，只能和JOIN一起使用
#而且两个表中的关联字段必须名称相同，而且只能表示=
#查询员工姓名与基本工资
SELECT last_name,job_title
FROM employees INNER JOIN jobs USING(job_id);


#n张表关联，需要n-1个关联条件
#查询员工姓名，基本工资，部门名称
SELECT last_name,job_title,department_name FROM employees,departments,jobs
WHERE employees.department_id = departments.department_id
AND employees.job_id = jobs.job_id;

SELECT last_name,job_title,department_name
FROM employees INNER JOIN departments INNER JOIN jobs
ON employees.department_id = departments.department_id
AND employees.job_id = jobs.job_id;
```

​		৹	我们要 `控制连接表的数量 `。多表连接就相当于嵌套 for 循环一样，非常消耗资源，会让 SQL 查询性能下 降得很严重，因此不要连接不必要的表。在许多 			  DBMS 中，也都会有最大连接表的限制。（超过三个表禁止 `join`。需要 `join` 的字段，数据类型保持绝对一致；多表关联查询时，保证被关联的字段需			  要有索引。    来源：阿里巴巴《Java开发手册》）

​	